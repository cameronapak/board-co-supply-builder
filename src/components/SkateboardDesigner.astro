---
import SkateboardTemplate from "@/components/SkateboardTemplate.astro";
---

<div x-data="skateboardDesigner" class="grid grid-cols-2 gap-4">
  <div
    class="relative h-[512px] w-fit"
    style="aspect-ratio: 428/1741;"
    @wheel.prevent.throttle.50ms="handleWheel($event)"
  >
    <!-- Snap lines - only visible when dragging -->
    <div x-show="isDragging" class="pointer-events-none absolute top-0 right-0 bottom-0 left-0 z-15">
      <!-- Vertical center line -->
      <div class="absolute top-0 bottom-0 w-px bg-blue-500 opacity-80" style="left: 50%;"></div>

      <!-- Horizontal center line -->
      <div class="absolute right-0 left-0 h-px bg-blue-500 opacity-80" style="top: 50%;"></div>
    </div>

    <!-- Background layer - full image with reduced opacity (always visible) -->
    <div
      x-show="imageUrl"
      class="absolute top-0 right-0 bottom-0 left-0 z-5 cursor-move"
      @mousedown.debounce.100ms="startPan($event)"
      @touchstart.debounce.100ms="startPan($event)"
    >
      <img
        :src="imageUrl"
        alt="Uploaded skateboard design background"
        class="pointer-events-none h-full w-full object-contain opacity-20 select-none"
        :style="`transform: translate(${panX}px, ${panY}px) scale(${zoom});`"
        draggable="false"
      />
    </div>

    <!-- Clipped layer - full opacity image only within skateboard bounds -->
    <div
      x-show="imageUrl"
      class="absolute top-0 right-0 bottom-0 left-0 z-10 cursor-move"
      style="clip-path: url(#skateboard-clip);"
      @mousedown.debounce.100ms="startPan($event)"
      @touchstart.debounce.100ms="startPan($event)"
    >
      <img
        :src="imageUrl"
        alt="Uploaded skateboard design"
        class="pointer-events-none h-full w-full object-contain select-none"
        :style="`transform: translate(${panX}px, ${panY}px) scale(${zoom});`"
        draggable="false"
      />
    </div>

    <SkateboardTemplate class="pointer-events-none absolute top-0 right-0 bottom-0 left-0 z-20 h-full w-full" />
  </div>

  <aside>
    <input type="file" accept="image/*" @change="handleFileChange($event)" />

    <div x-show="imageUrl" class="mt-4 text-sm text-gray-600">
      <p>Drag the image to reposition it on the skateboard</p>
      <p class="mt-1 text-xs text-gray-500">
        The faded image shows the full area - the bright version shows what will be visible on the skateboard
      </p>
      <p class="mt-1 text-xs text-blue-600">
        Blue center lines appear when dragging - image snaps to center when close
      </p>
      <p class="mt-1 text-xs text-green-600">Use mouse wheel or zoom buttons to scale the image</p>

      <!-- Zoom Controls -->
      <div class="mt-3 flex items-center gap-3">
        <div class="flex items-center gap-2">
          <button
            @click="zoomOut()"
            class="rounded bg-gray-200 px-2 py-1 text-sm hover:bg-gray-300"
            :disabled="zoom <= minZoom"
          >
            âˆ’
          </button>
          <span class="min-w-[60px] text-center text-xs text-gray-600" x-text="`${Math.round(zoom * 100)}%`"></span>
          <button
            @click="zoomIn()"
            class="rounded bg-gray-200 px-2 py-1 text-sm hover:bg-gray-300"
            :disabled="zoom >= maxZoom"
          >
            +
          </button>
        </div>
        <button @click="resetZoom()" class="rounded bg-gray-200 px-3 py-1 text-sm hover:bg-gray-300">
          Fit to Size
        </button>
      </div>

      <!-- Position Controls -->
      <div class="mt-3 flex flex-wrap gap-2">
        <button @click="centerImage()" class="rounded bg-blue-100 px-3 py-1 text-sm text-blue-700 hover:bg-blue-200">
          Center
        </button>
        <button @click="resetPosition()" class="rounded bg-gray-200 px-3 py-1 text-sm hover:bg-gray-300">
          Reset Position
        </button>
        <button @click="resetAll()" class="rounded bg-red-100 px-3 py-1 text-sm text-red-700 hover:bg-red-200">
          Reset All
        </button>
      </div>
    </div>
  </aside>
</div>

<script>
  import Alpine from "alpinejs";

  document.addEventListener("alpine:init", () => {
    Alpine.data("skateboardDesigner", function () {
      return {
        imageUrl: "",
        panX: 0,
        panY: 0,
        zoom: 1,
        minZoom: 0.1,
        maxZoom: 5,
        zoomStep: 0.1,
        isDragging: false,
        startX: 0,
        startY: 0,
        initialPanX: 0,
        initialPanY: 0,
        snapThreshold: 15, // pixels within which snapping occurs
        containerWidth: 0,
        containerHeight: 0,

        init() {
          // Get container dimensions for snap calculations
          this.$nextTick(() => {
            const container = this.$el.querySelector('[style*="aspect-ratio"]') as HTMLElement;
            if (container) {
              this.containerWidth = container.offsetWidth;
              this.containerHeight = container.offsetHeight;
            }
          });
        },

        handleFileChange(event: Event) {
          const file = (event.target as HTMLInputElement).files?.[0];
          if (!file) {
            return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            this.imageUrl = e.target?.result as string;
            this.resetAll();
          };
          reader.readAsDataURL(file);
        },

        handleWheel(event: WheelEvent) {
          if (!this.imageUrl) return;

          const delta = event.deltaY > 0 ? -this.zoomStep : this.zoomStep;
          const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom + delta));

          if (newZoom !== this.zoom) {
            this.zoom = newZoom;
          }
        },

        zoomIn() {
          const newZoom = Math.min(this.maxZoom, this.zoom + this.zoomStep);
          this.zoom = newZoom;
        },

        zoomOut() {
          const newZoom = Math.max(this.minZoom, this.zoom - this.zoomStep);
          this.zoom = newZoom;
        },

        resetZoom() {
          this.zoom = 1;
        },

        startPan(event: MouseEvent | TouchEvent) {
          this.isDragging = true;
          this.initialPanX = this.panX;
          this.initialPanY = this.panY;

          if (event instanceof MouseEvent) {
            this.startX = event.clientX;
            this.startY = event.clientY;
          } else {
            this.startX = event.touches[0].clientX;
            this.startY = event.touches[0].clientY;
          }

          // Update container dimensions in case of resize
          const container = this.$el.querySelector('[style*="aspect-ratio"]') as HTMLElement;
          if (container) {
            this.containerWidth = container.offsetWidth;
            this.containerHeight = container.offsetHeight;
          }

          // Add global event listeners
          document.addEventListener("mousemove", this.handlePan.bind(this));
          document.addEventListener("mouseup", this.endPan.bind(this));
          document.addEventListener("touchmove", this.handlePan.bind(this));
          document.addEventListener("touchend", this.endPan.bind(this));

          event.preventDefault();
        },

        handlePan(event: MouseEvent | TouchEvent) {
          if (!this.isDragging) return;

          let currentX, currentY;
          if (event instanceof MouseEvent) {
            currentX = event.clientX;
            currentY = event.clientY;
          } else {
            currentX = event.touches[0].clientX;
            currentY = event.touches[0].clientY;
          }

          const deltaX = currentX - this.startX;
          const deltaY = currentY - this.startY;

          let newPanX = this.initialPanX + deltaX;
          let newPanY = this.initialPanY + deltaY;

          // Apply snapping
          const snapped = this.applySnapping(newPanX, newPanY);
          this.panX = snapped.x;
          this.panY = snapped.y;

          event.preventDefault();
        },

        applySnapping(panX: number, panY: number) {
          // Define center snap positions
          const centerX = this.containerWidth * 0.5; // 50% (center)
          const centerY = this.containerHeight * 0.5; // 50% (center)

          let snappedX = panX;
          let snappedY = panY;

          // Check horizontal center snapping
          // The image center is at containerWidth/2 + panX
          const imageCenterX = this.containerWidth / 2 + panX;
          if (Math.abs(imageCenterX - centerX) <= this.snapThreshold) {
            snappedX = centerX - this.containerWidth / 2;
          }

          // Check vertical center snapping
          // The image center is at containerHeight/2 + panY
          const imageCenterY = this.containerHeight / 2 + panY;
          if (Math.abs(imageCenterY - centerY) <= this.snapThreshold) {
            snappedY = centerY - this.containerHeight / 2;
          }

          return { x: snappedX, y: snappedY };
        },

        endPan() {
          this.isDragging = false;

          // Remove global event listeners
          document.removeEventListener("mousemove", this.handlePan.bind(this));
          document.removeEventListener("mouseup", this.endPan.bind(this));
          document.removeEventListener("touchmove", this.handlePan.bind(this));
          document.removeEventListener("touchend", this.endPan.bind(this));
        },

        resetPosition() {
          this.panX = 0;
          this.panY = 0;
        },

        resetAll() {
          this.panX = 0;
          this.panY = 0;
          this.zoom = 1;
        },

        // Helper method for quick positioning
        centerImage() {
          this.panX = 0;
          this.panY = 0;
        }
      };
    });
  });
</script>
