---
import SkateboardTemplate from "@/components/SkateboardTemplate.astro";
---

<div x-data="skateboardDesigner" class="grid grid-cols-2 gap-8">
  <main class="bg-secondary flex justify-center overflow-hidden rounded-xl border p-6">
    <div
      class="relative h-[512px] w-fit"
      style="aspect-ratio: 428/1741;"
      @wheel.prevent.throttle.50ms="handleWheel($event)"
    >
      <!-- Snap lines - only visible when dragging -->
      <div x-show="isDragging" class="pointer-events-none absolute top-0 right-0 bottom-0 left-0 z-15">
        <!-- Vertical center line -->
        <div class="absolute top-0 bottom-0 w-px bg-blue-500 opacity-80" style="left: 50%;"></div>

        <!-- Horizontal center line -->
        <div class="absolute right-0 left-0 h-px bg-blue-500 opacity-80" style="top: 50%;"></div>
      </div>

      <!-- Background layer - full image with reduced opacity (always visible) -->
      <div
        x-show="imageUrl"
        class="absolute top-0 right-0 bottom-0 left-0 z-5 cursor-move"
        @mousedown="startPan($event)"
        @touchstart="startPan($event)"
      >
        <img
          :src="imageUrl"
          alt="Uploaded skateboard design background"
          class="pointer-events-none h-full w-full object-contain opacity-10 select-none"
          :style="`transform: translate(${panX}px, ${panY}px) scale(${zoom}) rotate(${rotation}deg);`"
          draggable="false"
        />
      </div>

      <!-- Clipped layer - full opacity image only within skateboard bounds -->
      <div
        x-show="imageUrl"
        class="absolute top-0 right-0 bottom-0 left-0 z-10 cursor-move"
        style="clip-path: url(#skateboard-clip);"
        @mousedown="startPan($event)"
        @touchstart="startPan($event)"
      >
        <img
          :src="imageUrl"
          alt="Uploaded skateboard design"
          class="pointer-events-none h-full w-full object-contain select-none"
          :style="`transform: translate(${panX}px, ${panY}px) scale(${zoom}) rotate(${rotation}deg);`"
          draggable="false"
        />
      </div>

      <SkateboardTemplate class="pointer-events-none absolute top-0 right-0 bottom-0 left-0 z-20 h-full w-full" />
    </div>
  </main>

  <aside class="flex w-full flex-col gap-4">
    <h1 class="heading-1">Skateboard Designer</h1>

    <div x-show="!imageUrl" class="relative w-full">
      <input
        x-ref="fileInput"
        class="absolute inset-0 cursor-pointer opacity-0"
        type="file"
        accept="image/*,application/pdf"
        @change="handleFileChange($event)"
        id="file-input"
      />
      <button
        :class="imageUrl ? 'btn-secondary w-full' : 'btn w-full'"
        type="button"
        @click="$el.previousElementSibling.click()"
      >
        Choose Image
      </button>
    </div>

    <div x-show="imageUrl">
      <p class="paragraph text-muted-foreground leading-tight">Drag the image to reposition it on the skateboard</p>

      <div class="mt-3 flex items-center gap-3 border-b pb-3">
        <div class="grid w-full grid-cols-[1fr_auto] gap-2">
          <div class="flex items-center gap-2">
            <p class="paragraph font-semibold">Zoom</p>
            <span class="text-muted-foreground min-w-[60px] text-start" x-text="`${Math.round(zoom * 100)}%`"></span>
          </div>

          <div class="flex items-center gap-2">
            <button @click="zoomOut()" class="btn-icon-outline" :disabled="zoom <= minZoom">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="24"
                height="24"
                color="#000000"
                fill="none"
              >
                <path d="M20 12L4 12" stroke="#000000" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"
                ></path>
              </svg>
            </button>

            <button @click="zoomIn()" class="btn-icon-outline" :disabled="zoom >= maxZoom">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="24"
                height="24"
                color="#000000"
                fill="none"
              >
                <path
                  d="M12 4V20M20 12H4"
                  stroke="#000000"
                  stroke-width="3"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <!-- Rotation Controls -->
      <div class="mt-3 flex items-center gap-3 border-b pb-3">
        <div class="grid w-full grid-cols-[1fr_auto] gap-2">
          <div class="flex items-center gap-2">
            <p class="paragraph font-semibold">Rotation</p>
            <span class="text-muted-foreground min-w-[60px] text-start" x-text="`${rotation}°`"></span>
          </div>

          <div class="flex items-center gap-2">
            <button @click="rotateLeft()" class="btn-icon-outline" title="Rotate 90° counter-clockwise">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="24"
                height="24"
                color="#000000"
                fill="none"
              >
                <path
                  d="M4 2V5.13219C4 5.42605 4.36724 5.55908 4.55527 5.33333C6.3854 3.2875 9.04499 2 12.0051 2C17.5251 2 22 6.47715 22 12C22 15.9582 19.7015 19.3793 16.367 21"
                  stroke="#000000"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path>
                <path
                  d="M11.7347 22.0001C12.2016 22.0001 12.6611 21.9688 13.1111 21.9084M2.26537 8.66675C2.15297 9.06394 2.06477 9.46536 2 9.86901M2.03457 13.5381C2.10487 13.9381 2.19644 14.3343 2.30852 14.7245M3.83292 17.9963C4.07124 18.3497 4.3296 18.69 4.6071 19.0147M7.42857 21.3607C7.78228 21.5632 8.15042 21.7464 8.53228 21.9084"
                  stroke="#000000"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path>
              </svg>
            </button>

            <button @click="rotateRight()" class="btn-icon-outline" title="Rotate 90° clockwise">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="24"
                height="24"
                color="#000000"
                fill="none"
              >
                <path
                  d="M20 2V5.13219C20 5.42605 19.6328 5.55908 19.4447 5.33333C17.6146 3.2875 14.955 2 11.9949 2C6.47485 2 2 6.47715 2 12C2 15.9582 4.29852 19.3793 7.63298 21"
                  stroke="#000000"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path>
                <path
                  d="M12.2653 22.0001C11.7984 22.0001 11.3389 21.9688 10.8889 21.9084M21.7346 8.66675C21.847 9.06394 21.9352 9.46536 22 9.86901M21.9654 13.5381C21.8951 13.9381 21.8036 14.3343 21.6915 14.7245M20.1671 17.9963C19.9288 18.3497 19.6704 18.69 19.3929 19.0147M16.5714 21.3607C16.2177 21.5632 15.8496 21.7464 15.4677 21.9084"
                  stroke="#000000"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <div class="grid w-full grid-cols-2 gap-2 border-b py-3">
        <button @click="resetAll()" class="btn-outline">Reset</button>
        <button @click="resetImage()" class="btn-outline">Change Image</button>
      </div>

      <button class="btn mt-4 w-full">Order My Board</button>
    </div>
  </aside>
</div>

<script>
  import Alpine from "alpinejs";
  import * as pdfjsLib from "pdfjs-dist/build/pdf";
  import { actions } from "astro:actions";

  pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdn.jsdelivr.net/npm/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;

  document.addEventListener("alpine:init", () => {
    Alpine.data("skateboardDesigner", function () {
      return {
        imageUrl: "",
        panX: 0,
        panY: 0,
        zoom: 1,
        rotation: 0,
        minZoom: 0.1,
        maxZoom: 5,
        zoomStep: 0.1,
        isDragging: false,
        startX: 0,
        startY: 0,
        initialPanX: 0,
        initialPanY: 0,
        snapThreshold: 15, // pixels within which snapping occurs
        containerWidth: 0,
        containerHeight: 0,

        init() {
          // Get container dimensions for snap calculations
          this.$nextTick(() => {
            const container = this.$el.querySelector('[style*="aspect-ratio"]') as HTMLElement;
            if (container) {
              this.containerWidth = container.offsetWidth;
              this.containerHeight = container.offsetHeight;
            }
          });
        },

        async handleFileChange(event: Event) {
          const file = (event.target as HTMLInputElement).files?.[0];
          if (!file) {
            return;
          }

          const formData = new FormData();
          formData.append("artwork", file);

          try {
            const { data: validationResult, error } = await actions.validate.validateArtwork(formData);

            if (error || !validationResult?.valid) {
              const errorMessage = error
                ? "An error occurred during validation"
                : validationResult?.message || "Validation failed";
              const suggestions = validationResult?.details?.suggestions?.join("\n- ");
              const alertMessage = `${errorMessage}\n\nSuggestions:\n${suggestions ? `- ${suggestions}` : "None"}`;
              window.alert(alertMessage);
              (this.$refs.fileInput as HTMLInputElement).value = ""; // Reset file input
              return;
            }
          } catch (error) {
            console.error("Validation request failed:", error);
            window.alert("An error occurred during file validation. Please try again.");
            (this.$refs.fileInput as HTMLInputElement).value = "";
            return;
          }

          if (file.type.startsWith("image/")) {
            const reader = new FileReader();
            reader.onload = (e) => {
              this.imageUrl = e.target?.result as string;
              this.resetAll();
            };
            reader.readAsDataURL(file);
          } else if (file.type === "application/pdf") {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            const page = await pdf.getPage(1); // Get the first page

            const viewport = page.getViewport({ scale: 1.5 }); // Adjust scale as needed
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            if (context) {
              const renderContext = {
                canvasContext: context,
                viewport: viewport
              };
              await page.render(renderContext).promise;
              this.imageUrl = canvas.toDataURL();
              this.resetAll();
            } else {
              console.error("Could not get canvas context");
            }
          }
        },

        handleWheel(event: WheelEvent) {
          if (!this.imageUrl) return;

          const delta = event.deltaY > 0 ? -this.zoomStep : this.zoomStep;
          const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom + delta));

          if (newZoom !== this.zoom) {
            this.zoom = newZoom;
          }
        },

        zoomIn() {
          const newZoom = Math.min(this.maxZoom, this.zoom + this.zoomStep);
          this.zoom = newZoom;
        },

        zoomOut() {
          const newZoom = Math.max(this.minZoom, this.zoom - this.zoomStep);
          this.zoom = newZoom;
        },

        resetZoom() {
          this.zoom = 1;
        },

        rotateLeft() {
          this.rotation = (this.rotation - 90) % 360;
          if (this.rotation < 0) {
            this.rotation += 360;
          }
        },

        rotateRight() {
          this.rotation = (this.rotation + 90) % 360;
        },

        resetRotation() {
          this.rotation = 0;
        },

        startPan(event: MouseEvent | TouchEvent) {
          this.isDragging = true;
          this.initialPanX = this.panX;
          this.initialPanY = this.panY;

          if (event instanceof MouseEvent) {
            this.startX = event.clientX;
            this.startY = event.clientY;
          } else {
            this.startX = event.touches[0].clientX;
            this.startY = event.touches[0].clientY;
          }

          // Update container dimensions in case of resize
          const container = this.$el.querySelector('[style*="aspect-ratio"]') as HTMLElement;
          if (container) {
            this.containerWidth = container.offsetWidth;
            this.containerHeight = container.offsetHeight;
          }

          // Add global event listeners
          document.addEventListener("mousemove", this.handlePan.bind(this));
          document.addEventListener("mouseup", this.endPan.bind(this));
          document.addEventListener("touchmove", this.handlePan.bind(this));
          document.addEventListener("touchend", this.endPan.bind(this));

          event.preventDefault();
        },

        handlePan(event: MouseEvent | TouchEvent) {
          if (!this.isDragging) return;

          let currentX, currentY;
          if (event instanceof MouseEvent) {
            currentX = event.clientX;
            currentY = event.clientY;
          } else {
            currentX = event.touches[0].clientX;
            currentY = event.touches[0].clientY;
          }

          const deltaX = currentX - this.startX;
          const deltaY = currentY - this.startY;

          let newPanX = this.initialPanX + deltaX;
          let newPanY = this.initialPanY + deltaY;

          // Apply snapping
          const snapped = this.applySnapping(newPanX, newPanY);
          this.panX = snapped.x;
          this.panY = snapped.y;

          event.preventDefault();
        },

        applySnapping(panX: number, panY: number) {
          // Define center snap positions
          const centerX = this.containerWidth * 0.5; // 50% (center)
          const centerY = this.containerHeight * 0.5; // 50% (center)

          let snappedX = panX;
          let snappedY = panY;

          // Check horizontal center snapping
          // The image center is at containerWidth/2 + panX
          const imageCenterX = this.containerWidth / 2 + panX;
          if (Math.abs(imageCenterX - centerX) <= this.snapThreshold) {
            snappedX = centerX - this.containerWidth / 2;
          }

          // Check vertical center snapping
          // The image center is at containerHeight/2 + panY
          const imageCenterY = this.containerHeight / 2 + panY;
          if (Math.abs(imageCenterY - centerY) <= this.snapThreshold) {
            snappedY = centerY - this.containerHeight / 2;
          }

          return { x: snappedX, y: snappedY };
        },

        endPan() {
          this.isDragging = false;

          // Remove global event listeners
          document.removeEventListener("mousemove", this.handlePan.bind(this));
          document.removeEventListener("mouseup", this.endPan.bind(this));
          document.removeEventListener("touchmove", this.handlePan.bind(this));
          document.removeEventListener("touchend", this.endPan.bind(this));
        },

        resetPosition() {
          this.panX = 0;
          this.panY = 0;
        },

        resetAll() {
          this.panX = 0;
          this.panY = 0;
          this.zoom = 1;
          this.rotation = 0;
        },

        resetImage() {
          this.imageUrl = "";
          (this.$refs.fileInput as HTMLInputElement).value = "";
          this.resetAll();
        },

        // Helper method for quick positioning
        centerImage() {
          this.panX = 0;
          this.panY = 0;
        }
      };
    });
  });
</script>
