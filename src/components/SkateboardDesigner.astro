---
import Logo from "@/components/Logo.astro";
import SkateboardTemplate from "@/components/SkateboardTemplate.astro";
import { actions } from "astro:actions";
import BuySkateboardButton from "./BuySkateboardButton.astro";

const { data, error: _error } = await Astro.callAction(actions.squarespace.getSkateboardProduct, {});

const deckShapes = [...new Set(data?.variants.map((variant) => variant.attributes.Shape))];
---

<div x-data="skateboardDesigner" class="gap-8 max-sm:flex max-sm:flex-col sm:grid sm:grid-cols-2">
  <main
    id="skateboard-designer"
    class="bg-secondary flex justify-center overflow-hidden rounded-xl border p-6 max-sm:h-[100vw] max-sm:-rotate-90"
  >
    <div
      class="relative h-full w-auto sm:h-[512px]"
      style="aspect-ratio: 428/1741;"
      @wheel.prevent.throttle.50ms="handleWheel($event)"
    >
      <!-- Snap lines - only visible when dragging -->
      <div x-cloak x-show="isDragging" class="pointer-events-none absolute top-0 right-0 bottom-0 left-0 z-15">
        <!-- Vertical center line -->
        <div class="absolute top-0 bottom-0 w-px bg-blue-500 opacity-80" style="left: 50%;"></div>

        <!-- Horizontal center line -->
        <div class="absolute right-0 left-0 h-px bg-blue-500 opacity-80" style="top: 50%;"></div>
      </div>

      <!-- Background layer - full image with reduced opacity (always visible) -->
      <div
        x-show="imageUrl"
        x-cloak
        class="absolute top-0 right-0 bottom-0 left-0 z-5 cursor-move"
        @mousedown="startPan($event)"
        @touchstart="startPan($event)"
      >
        <img
          :src="imageUrl"
          alt="Uploaded skateboard design background"
          class="pointer-events-none h-full w-full object-contain opacity-10 select-none"
          :style="`transform: translate(${panX}px, ${panY}px) scale(${zoom}) rotate(${rotation}deg);`"
          draggable="false"
        />
      </div>

      <!-- Clipped layer - full opacity image only within skateboard bounds -->
      <div
        x-show="imageUrl"
        x-cloak
        class="absolute top-0 right-0 bottom-0 left-0 z-10 cursor-move"
        style="clip-path: url(#skateboard-clip);"
        @mousedown="startPan($event)"
        @touchstart="startPan($event)"
      >
        <img
          :src="imageUrl"
          alt="Uploaded skateboard design"
          class="pointer-events-none h-full w-full object-contain select-none"
          :style="`transform: translate(${panX}px, ${panY}px) scale(${zoom}) rotate(${rotation}deg);`"
          draggable="false"
        />
      </div>

      <SkateboardTemplate class="pointer-events-none absolute top-0 right-0 bottom-0 left-0 z-20 h-full w-full" />
    </div>
  </main>

  <aside class="flex w-full flex-col gap-4">
    <div class="flex items-center gap-4">
      <Logo class="h-[48px] w-auto" />

      <h1 class="heading-1 leading-none font-bold">
        <span class="block">Skateboard</span>
        <span class="block">Designer</span>
      </h1>
    </div>

    <div x-show="!imageUrl" class="relative w-full">
      <input
        x-ref="fileInput"
        class="absolute inset-0 cursor-pointer opacity-0"
        type="file"
        accept="image/*,application/pdf,.HEIC,.HEIF"
        @change="handleFileChange($event)"
        id="file-input"
      />
      <button
        :class="imageUrl ? 'btn-secondary w-full' : 'btn w-full'"
        type="button"
        @click="$el.previousElementSibling.click()"
      >
        Choose Image
      </button>
    </div>

    <div x-show="imageUrl" x-cloak x-collapse>
      <p class="paragraph text-muted-foreground leading-tight">Drag the image to reposition it on the skateboard</p>

      <section>
        <div class="mt-3 flex items-center gap-3 border-b pb-3">
          <div class="grid w-full grid-cols-[1fr_auto] gap-2">
            <div class="flex items-center gap-2">
              <p class="paragraph font-semibold">Zoom</p>
              <span class="text-muted-foreground min-w-[60px] text-start" x-text="`${Math.round(zoom * 100)}%`"></span>
            </div>

            <div class="flex items-center gap-2">
              <button @click="zoomOut()" class="btn-icon-outline" :disabled="zoom <= minZoom">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  width="24"
                  height="24"
                  color="#000000"
                  fill="none"
                >
                  <path d="M20 12L4 12" stroke="#000000" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"
                  ></path>
                </svg>
              </button>

              <button @click="zoomIn()" class="btn-icon-outline" :disabled="zoom >= maxZoom">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  width="24"
                  height="24"
                  color="#000000"
                  fill="none"
                >
                  <path
                    d="M12 4V20M20 12H4"
                    stroke="#000000"
                    stroke-width="3"
                    stroke-linecap="round"
                    stroke-linejoin="round"></path>
                </svg>
              </button>
            </div>
          </div>
        </div>

        <!-- Rotation Controls -->
        <div class="mt-3 flex items-center gap-3 border-b pb-3">
          <div class="grid w-full grid-cols-[1fr_auto] gap-2">
            <div class="flex items-center gap-2">
              <p class="paragraph font-semibold">Rotation</p>
              <span class="text-muted-foreground min-w-[60px] text-start" x-text="`${rotation}°`"></span>
            </div>

            <div class="flex items-center gap-2">
              <button @click="rotateLeft()" class="btn-icon-outline" title="Rotate 90° counter-clockwise">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  width="24"
                  height="24"
                  color="#000000"
                  fill="none"
                >
                  <path
                    d="M4 2V5.13219C4 5.42605 4.36724 5.55908 4.55527 5.33333C6.3854 3.2875 9.04499 2 12.0051 2C17.5251 2 22 6.47715 22 12C22 15.9582 19.7015 19.3793 16.367 21"
                    stroke="#000000"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"></path>
                  <path
                    d="M11.7347 22.0001C12.2016 22.0001 12.6611 21.9688 13.1111 21.9084M2.26537 8.66675C2.15297 9.06394 2.06477 9.46536 2 9.86901M2.03457 13.5381C2.10487 13.9381 2.19644 14.3343 2.30852 14.7245M3.83292 17.9963C4.07124 18.3497 4.3296 18.69 4.6071 19.0147M7.42857 21.3607C7.78228 21.5632 8.15042 21.7464 8.53228 21.9084"
                    stroke="#000000"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"></path>
                </svg>
              </button>

              <button @click="rotateRight()" class="btn-icon-outline" title="Rotate 90° clockwise">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  width="24"
                  height="24"
                  color="#000000"
                  fill="none"
                >
                  <path
                    d="M20 2V5.13219C20 5.42605 19.6328 5.55908 19.4447 5.33333C17.6146 3.2875 14.955 2 11.9949 2C6.47485 2 2 6.47715 2 12C2 15.9582 4.29852 19.3793 7.63298 21"
                    stroke="#000000"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"></path>
                  <path
                    d="M12.2653 22.0001C11.7984 22.0001 11.3389 21.9688 10.8889 21.9084M21.7346 8.66675C21.847 9.06394 21.9352 9.46536 22 9.86901M21.9654 13.5381C21.8951 13.9381 21.8036 14.3343 21.6915 14.7245M20.1671 17.9963C19.9288 18.3497 19.6704 18.69 19.3929 19.0147M16.5714 21.3607C16.2177 21.5632 15.8496 21.7464 15.4677 21.9084"
                    stroke="#000000"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"></path>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </section>

      <!-- Pricing Section -->
      <div class="flex flex-col">
        <div class="grid grid-cols-[1fr_auto] items-center gap-2 border-b py-3">
          <select x-model="$store.order.shape" class="select w-full">
            <option>Select a shape</option>
            <optgroup label="Deck Shape">
              {deckShapes.map((shape) => <option value={shape}>{shape}</option>)}
            </optgroup>
          </select>

          <button @click="$refs.deckShapeDialog.showModal()" class="text-muted-foreground">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
              class="size-6"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z"
              ></path>
            </svg>
          </button>

          <!-- <img src="http://localhost:4321/api/media/file/deck-shapes.png" /> -->
        </div>

        <dialog
          x-ref="deckShapeDialog"
          id="dialog-deck-shape-definition"
          class="dialog max-h-[612px] w-full sm:max-w-[425px]"
          aria-labelledby="dialog-deck-shape-definition-title"
          aria-describedby="dialog-deck-shape-definition-description"
          @click="(event.target === $el) ? $el.close() : null"
        >
          <article>
            <header>
              <h2 id="dialog-deck-shape-definition-title">Deck Shapes</h2>
              <p id="dialog-deck-shape-definition-description">Here are the two deck shapes we offer.</p>
            </header>

            <section>
              <img src="http://localhost:4321/api/media/file/deck-shapes.png" class="max-h-[256px] rounded-xl border" />
            </section>

            <footer>
              <button class="btn-outline" onclick="this.closest('dialog').close()">Close</button>
            </footer>

            <button type="button" aria-label="Close dialog" onclick="this.closest('dialog').close()">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="lucide lucide-x-icon lucide-x"
              >
                <path d="M18 6 6 18"></path>
                <path d="m6 6 12 12"></path>
              </svg>
            </button>
          </article>
        </dialog>

        <div class="border-b py-3">
          <select :disabled="!$store.order.shape" x-model="$store.order.skateboardVariant" class="select w-full">
            <option>Select a size</option>
            <optgroup label="Deck Width">
              {
                data?.variants
                  .sort((a, b) => a.attributes.Size - b.attributes.Size)
                  .map((variant) => (
                    <template x-if={`"${variant.attributes.Shape}" === $store.order.shape`}>
                      <option value={variant.id}>{variant.attributes.Size}"</option>
                    </template>
                  ))
              }
            </optgroup>
          </select>
        </div>

        <!-- {
          data?.variants.map((variant) => (
            <template x-if={`$store.order.skateboardVariant === "${variant.id}"`}>
              <ul>
                <li>Size: {variant.attributes.Size}"</li>
                <li>
                  Price: ${variant.pricing.onSale ? variant.pricing.salePrice.value : variant.pricing.basePrice.value}
                </li>
                <li>Remaining Stock: {variant.stock.quantity}</li>
              </ul>
            </template>
          ))
        } -->
      </div>

      <section class="mt-4">
        <BuySkateboardButton />
      </section>

      <button @click="resetImage()" class="btn-outline mt-4 w-full">Restart</button>
    </div>
  </aside>

  <script>
    import Alpine from "alpinejs";
    // @ts-expect-error - pdfjs works, but has an error
    import * as pdfjsLib from "pdfjs-dist/build/pdf";
    import { actions } from "astro:actions";
    import { instantiateStore, getStore } from "@/alpine/store";
    import { heicTo, isHeic } from "heic-to";

    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdn.jsdelivr.net/npm/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;

    document.addEventListener("alpine:init", () => {
      instantiateStore();

      Alpine.data("skateboardDesigner", function () {
        return {
          imageUrl: "",
          panX: 0,
          panY: 0,
          zoom: 1,
          rotation: 0,
          minZoom: 0.1,
          maxZoom: 5,
          zoomStep: 0.1,
          isDragging: false,
          startX: 0,
          startY: 0,
          initialPanX: 0,
          initialPanY: 0,
          snapThreshold: 15, // pixels within which snapping occurs
          containerWidth: 0,
          containerHeight: 0,

          init() {
            // Get container dimensions for snap calculations
            this.$nextTick(() => {
              const container = this.$el.querySelector('[style*="aspect-ratio"]') as HTMLElement;
              if (container) {
                this.containerWidth = container.offsetWidth;
                this.containerHeight = container.offsetHeight;
              }
            });
          },

          async validateStripeSession() {
            const sessionId = new URLSearchParams(window.location.search).get("session_id");
            if (!sessionId) {
              return;
            }

            // Remove the session_id url param
            const url = new URL(window.location.href);
            url.searchParams.delete("session_id");
            window.history.replaceState({}, "", url.toString());

            // const session = await actions.stripe.validateSubscription.orThrow({ sessionId, imei: this.imei });
            // if (!session) {
            //   return;
            // }

            // if (session.isSubscribed) {
            //   this.showSuccessToast("Congratulations! You're subscribed.");
            //   this.showConfetti();
            //   this.isSubscribed = true;
            //   await this.addFeatureToDevice(KNOX_USER_GROUPS.SUBSCRIBED);
            //   this.features.push(KNOX_USER_GROUPS.SUBSCRIBED);
            // } else {
            //   this.showErrorToast("Subscription validation failed. Please try again.");
            // }
          },

          get store() {
            return getStore();
          },

          async handleFileChange(event: Event) {
            const file = (event.target as HTMLInputElement).files?.[0];
            if (!file) {
              return;
            }

            // Convert HEIC files to JPEG before processing
            let processedFile = file;

            if (await isHeic(file)) {
              try {
                // Convert to JPEG
                const jpeg = await heicTo({
                  blob: file,
                  type: "image/jpeg",
                  quality: 0.8
                });

                // Create a new File object with the converted JPEG data
                processedFile = new File([jpeg], file.name.replace(/\.(heic|heif)$/i, ".jpg"), {
                  type: "image/jpeg",
                  lastModified: Date.now()
                });
              } catch (conversionError) {
                console.error("HEIC conversion failed:", conversionError);
                window.alert("Failed to convert HEIC file. Please try a different format.");
                (this.$refs.fileInput as HTMLInputElement).value = "";
                return;
              }
            }

            const formData = new FormData();
            formData.append("artwork", processedFile);
            this.store.artwork = processedFile;

            try {
              const { data: validationResult, error } = await actions.validate.validateArtwork(formData);

              if (error || !validationResult?.valid) {
                const errorMessage = error
                  ? "An error occurred during validation"
                  : validationResult?.message || "Validation failed";
                const suggestions = validationResult?.details?.suggestions?.join("\n- ");
                const alertMessage = `${errorMessage}\n\nSuggestions:\n${suggestions ? `- ${suggestions}` : "None"}`;
                window.alert(alertMessage);
                (this.$refs.fileInput as HTMLInputElement).value = ""; // Reset file input
                return;
              }

              if (validationResult.processedFile) {
                let processedFile =
                  new File([validationResult.processedFile], "processed-artwork.jpg", {
                    type: "image/jpeg",
                    lastModified: Date.now()
                  }) || null;
                this.store.artwork = processedFile;
              }
            } catch (error) {
              console.error("Validation request failed:", error);
              window.alert("An error occurred during file validation. Please try again.");
              (this.$refs.fileInput as HTMLInputElement).value = "";
              return;
            }

            if (processedFile.type.startsWith("image/")) {
              const reader = new FileReader();
              reader.onload = (e) => {
                this.imageUrl = e.target?.result as string;
                this.resetAll();
              };
              reader.readAsDataURL(processedFile);
            } else if (file.type === "application/pdf") {
              const arrayBuffer = await file.arrayBuffer();
              const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
              const page = await pdf.getPage(1); // Get the first page

              const viewport = page.getViewport({ scale: 1.5 }); // Adjust scale as needed
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              if (context) {
                const renderContext = {
                  canvasContext: context,
                  viewport: viewport
                };
                await page.render(renderContext).promise;
                this.imageUrl = canvas.toDataURL();
                this.resetAll();
              } else {
                console.error("Could not get canvas context");
              }
            }
          },

          handleWheel(event: WheelEvent) {
            if (!this.imageUrl) return;

            const delta = event.deltaY > 0 ? -this.zoomStep : this.zoomStep;
            const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom + delta));

            if (newZoom !== this.zoom) {
              this.zoom = newZoom;
            }
          },

          zoomIn() {
            const newZoom = Math.min(this.maxZoom, this.zoom + this.zoomStep);
            this.zoom = newZoom;
          },

          zoomOut() {
            const newZoom = Math.max(this.minZoom, this.zoom - this.zoomStep);
            this.zoom = newZoom;
          },

          resetZoom() {
            this.zoom = 1;
          },

          rotateLeft() {
            this.rotation = (this.rotation - 90) % 360;
            if (this.rotation < 0) {
              this.rotation += 360;
            }
          },

          rotateRight() {
            this.rotation = (this.rotation + 90) % 360;
          },

          resetRotation() {
            this.rotation = 0;
          },

          startPan(event: MouseEvent | TouchEvent) {
            this.isDragging = true;
            this.initialPanX = this.panX;
            this.initialPanY = this.panY;

            if (event instanceof MouseEvent) {
              this.startX = event.clientX;
              this.startY = event.clientY;
            } else {
              this.startX = event.touches[0].clientX;
              this.startY = event.touches[0].clientY;
            }

            // Update container dimensions in case of resize
            const container = this.$el.querySelector('[style*="aspect-ratio"]') as HTMLElement;
            if (container) {
              this.containerWidth = container.offsetWidth;
              this.containerHeight = container.offsetHeight;
            }

            // Add global event listeners
            document.addEventListener("mousemove", this.handlePan.bind(this));
            document.addEventListener("mouseup", this.endPan.bind(this));
            document.addEventListener("touchmove", this.handlePan.bind(this));
            document.addEventListener("touchend", this.endPan.bind(this));

            event.preventDefault();
          },

          handlePan(event: MouseEvent | TouchEvent) {
            if (!this.isDragging) return;

            let currentX, currentY;
            if (event instanceof MouseEvent) {
              currentX = event.clientX;
              currentY = event.clientY;
            } else {
              currentX = event.touches[0].clientX;
              currentY = event.touches[0].clientY;
            }

            let deltaX = currentX - this.startX;
            let deltaY = currentY - this.startY;

            // On mobile, rotate movement -90 degrees
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
              // Swap and invert axes for -90 degree rotation
              const rotatedDeltaX = -deltaY;
              const rotatedDeltaY = deltaX;
              deltaX = rotatedDeltaX;
              deltaY = rotatedDeltaY;
            }

            let newPanX = this.initialPanX + deltaX;
            let newPanY = this.initialPanY + deltaY;

            // Apply snapping
            const snapped = this.applySnapping(newPanX, newPanY);
            this.panX = snapped.x;
            this.panY = snapped.y;

            event.preventDefault();
          },

          applySnapping(panX: number, panY: number) {
            // Define center snap positions
            const centerX = this.containerWidth * 0.5; // 50% (center)
            const centerY = this.containerHeight * 0.5; // 50% (center)

            let snappedX = panX;
            let snappedY = panY;

            // Check horizontal center snapping
            // The image center is at containerWidth/2 + panX
            const imageCenterX = this.containerWidth / 2 + panX;
            if (Math.abs(imageCenterX - centerX) <= this.snapThreshold) {
              snappedX = centerX - this.containerWidth / 2;
            }

            // Check vertical center snapping
            // The image center is at containerHeight/2 + panY
            const imageCenterY = this.containerHeight / 2 + panY;
            if (Math.abs(imageCenterY - centerY) <= this.snapThreshold) {
              snappedY = centerY - this.containerHeight / 2;
            }

            return { x: snappedX, y: snappedY };
          },

          endPan() {
            this.isDragging = false;

            // Remove global event listeners
            document.removeEventListener("mousemove", this.handlePan.bind(this));
            document.removeEventListener("mouseup", this.endPan.bind(this));
            document.removeEventListener("touchmove", this.handlePan.bind(this));
            document.removeEventListener("touchend", this.endPan.bind(this));
          },

          resetPosition() {
            this.panX = 0;
            this.panY = 0;
          },

          resetAll() {
            this.panX = 0;
            this.panY = 0;
            this.zoom = 1;
            this.rotation = 0;
          },

          resetImage() {
            this.imageUrl = "";
            (this.$refs.fileInput as HTMLInputElement).value = "";
            this.resetAll();
          },

          // Helper method for quick positioning
          centerImage() {
            this.panX = 0;
            this.panY = 0;
          }
        };
      });
    });
  </script>
</div>
